# Домашнее задание к занятию "`«Репликация и масштабирование. Часть 2»`" - `Копшев Юрий`


---

### Задание 1.

Опишите основные преимущества использования масштабирования методами:

 - активный master-сервер и пассивный репликационный slave-сервер;
 - master-сервер и несколько slave-серверов

Ответ:

1) Активный master и пассивный slave
 
 Схема: один основной сервер (master) принимает все записи и, как правило, почти все чтения, один репликационный сервер (slave) держит копию данных и используется ограниченно.

Основные преимущества:

	•	Резерв и отказоустойчивость
	•	Slave содержит почти актуальную копию базы, его можно быстро «повысить» до master при поломке основного узла, уменьшая простой. 
	•	Slave можно использовать для резервного копирования, не нагружая основной сервер. 
	•	Безопасные тяжелые операции
	•	На slave удобно выполнять долгие аналитические запросы, отчёты и бэкапы — это не мешает онлайн‑нагрузке на master. 
	•	Можно тестировать миграции схемы или обновления на slave, а затем применять их на master.
	•	Относительная простота
	•	Архитектура проста: одно место для записи, простая логика приложения, меньше рисков конфликтов при изменениях. 

Эта схема больше про отказоустойчивость и безопасность, чем про масштабирование по чтению

2) Один master и несколько slave

Схема: один сервер master принимает все операции записи и обновления, несколько slave-реплик обслуживают запросы на чтение (read‑replicas). 

Основные преимущества:

	•	Масштабирование чтения
	•	Чтения можно распределять по многим репликам, поэтому суммарное количество одновременных read‑запросов растёт почти линейно с числом slave. 
	•	Master разгружается и концентрируется на записях и транзакциях, что уменьшает задержки при изменениях данных. 
	•	Высокая доступность
	•	При отказе одного из slave запросы перенаправляются на оставшиеся реплики, сервис продолжает работать. 
	•	Один из slave при отказе master может быть повышен до нового master, что сокращает время простоя приложения. 
	•	Гибкость и геораспределение
	•	Часть slave‑серверов можно размещать ближе к пользователям (по регионам), уменьшая сетевые задержки. 
	•	Нагрузку аналитики, отчётности и сервисов кэша можно вынести на отдельные реплики, не влияя на боевой трафик. 
     
Эта схема уже даёт реальное масштабирование по чтению и базовую отказоустойчивость, оставаясь относительно простой: один источник истины для всех записей.

 
---

### Задание 2.

Предлагаемая архитектура:
Разделим систему вертикально по функциональным областям, а внутри некоторых областей применим горизонтальный шардинг по пользователям или регионам.

1) Кластер пользователей (User DB Cluster)

Назначение: аутентификация, профили пользователей, их заказы и т.п.

	Вертикально:
	•	Отдельная БД  users_service  (схема:  users , возможно  user_profiles ,  user_settings итд ).

	Горизонтально внутри  users:
	•	Таблица  users  шардинг по диапазону идентификаторов. 
	
    
Пример:

	•	Shard U1: пользователи с ID 1–1 000 000
	•	Shard U2: пользователи с ID 1 000 001–2 000 000 и т д. 


2) Кластер книг (Books DB Cluster)

Назначение: каталог книг (Например: название, автор, жанр, ISBN, цена, наличие).

	Вертикально:
	•	Отдельная БД  catalog_service  (таблица  books ).

	Горизонтально внутри  books:
    Варианты ключа:
	•	по жанру/категории,
	•	по диапазону book_id,
	•	по магазину‑владельцу, если книги сильно связаны с конкретными магазинами. 

Пример:

	•	Shard B1: книги жанров A–M или ID 1–1 000 000,
	•	Shard B2: книги жанров N–Z или ID > 1 000 000

3) Кластер магазинов (Stores DB Cluster)

Назначение: информация о магазинах, их адресах, остатках книг и региональной привязке.

	Вертикально:
	•	Отдельная БД  stores_service  (таблицы  stores ,  store_inventory  итд).

	Горизонтально:
	•	Логично шардировать по региону магазина (страна / город / зона). 

Пример:

	•	Shard S1: магазины в Европе,
	•	Shard S2: магазины в Азии и т.д.



![Блохсхема](https://github.com/YuriKopshev/elk_home_work/blob/main/task2.txt)


---


